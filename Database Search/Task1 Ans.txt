1. Comparison: Flat File Systems vs. Relational Databases

Flat File Systems store data in simple files (like Excel, CSV, text files), while Relational Databases store data in structured tables with relationships.

Below is a clear comparison covering all required points.

| Feature                         | Flat File Systems                                                                                                     | Relational Databases (RDBMS)                                                                |
| ------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| **Structure**                   | Data stored in a single file or multiple independent files (e.g., CSV, TXT). No enforced structure beyond formatting. | Data stored in tables (rows & columns) with defined schema (data types, constraints, keys). |
| **Data Redundancy**             | Very high — the same data is repeated across files because there is no central reference.                             | Low — normalization reduces duplication using keys and relationships.                       |
| **Relationships**               | No built-in relationships. Files are isolated, and relationships must be handled manually.                            | Supports relationships using Primary Keys, Foreign Keys, and constraints.                   |
| **Example Usage**               | Small datasets, configuration files, spreadsheets, simple logs.                                                       | Business systems, banking, ecommerce, student systems, inventory, ERP, CRM.                 |
| **Drawbacks**                   | • No relationships                                                                                                    |                                                                                             |
| • Hard to update                |                                                                                                                       |                                                                                             |
| • High redundancy               |                                                                                                                       |                                                                                             |
| • Slow for large data           |                                                                                                                       |                                                                                             |
| • No security or access control | • Requires installation of DBMS                                                                                       |                                                                                             |
| • More complex design           |                                                                                                                       |                                                                                             |
| • Needs skilled administration  |                                                                                                                       |                                                                                             |

Short Explanation :
Structure

Flat File Systems store data in simple formats like .csv, .txt, or spreadsheets. They lack strict data types and rules.

Relational Databases store data in organized tables with a fixed structure defined by a schema.

Data Redundancy

In flat files, the same information may appear many times — leading to inconsistency.

RDBMS minimizes redundancy using normalization and relationships.

Relationships

Flat files do not support relationships automatically.

RDBMS supports relationships using primary keys, foreign keys, and constraints.

Example Usage

Flat files → small applications, simple storage, Excel reports.

RDBMS → banking, hospitals, schools, CRM, ecommerce, HR systems.

Drawbacks

Flat files: poor performance, no security, no relationships, lots of redundancy.

RDBMS: requires setup, database knowledge, and more hardware resources.


---------------------------------------------------------------------------------

3. Roles in a Database System

### System Analyst
- Gathers and analyzes business requirements.
- Maps business processes to data requirements and system interactions.
- Works with stakeholders to define functional and non-functional specs.

### Database Designer
- Translates requirements into logical and physical schemas.
- Decides normalization, keys, relationships, and indexing strategies.
- Produces ER diagrams and schema documentation.

### Database Developer
- Implements database objects: tables, views, stored procedures, triggers.
- Writes and optimizes queries and implements business logic in the DB.
- Works on ETL jobs, data migration scripts and version control for DB code.

### DBA (Database Administrator)
- Responsible for installation, configuration, monitoring, tuning, backup/restore, security and availability.
- Manages user accounts, capacity planning, replication, patching and disaster recovery.

### Application Developer
- Uses database via application code (ORMs or SQL) to create features.
- Designs data access layers, writes queries, and ensures transactional integrity from the app side.

### BI Developer
- Builds reports, dashboards, data pipelines, and analytical models.
- Works with data warehouses, OLAP cubes, and ETL to enable analytics and insights.
-----------------------------------------------------------------------------------

## 4. Additional Research Topics

### Types of Databases

#### Relational vs Non-Relational
- **Relational (RDBMS):**
  - Structured tables, schema-first, ACID transactions.
  - Examples: SQL Server, MySQL, PostgreSQL, Oracle.
  - Good for transactional systems and structured data.
- **Non-Relational (NoSQL):**
  - Schemeless or flexible schema: document (MongoDB), wide-column (Cassandra), key-value (Redis), graph (Neo4j).
  - Optimized for scalability, large volumes, flexible data models, or specific query patterns.

#### Centralized vs Distributed vs Cloud Databases
- **Centralized:**
  - Single server or single data center. Simpler management, potential single point of failure.
- **Distributed:**
  - Data spread across nodes/regions, can provide high availability, fault tolerance, low-latency read near users. Example: Cassandra, CockroachDB.
- **Cloud Databases:**
  - Managed DB services hosted by cloud providers (Amazon RDS/Aurora, Azure SQL, Google Cloud Spanner).
  - Offer scaling, snapshots, automatic patching and backups.

#### Use case examples
- **Relational**: Bank transactions, ERP, inventory systems.
- **Document DB (NoSQL)**: Content management, user profiles, logs.
- **Wide-column**: Time-series, telemetry, high-write workloads.
- **Graph DB**: Social networks, recommendation engines.

-------------------------------------------------------------------------------
### Cloud Storage and Databases

#### What is Cloud Storage and how does it relate to databases?
- **Cloud Storage** is object/block/file storage provided as a service (e.g., S3, Azure Blob) for files, backups, and large objects.
- Databases in the cloud may use cloud storage for backups, data files, or as the underlying storage layer. Managed databases abstract hardware & storage management from users.

#### Advantages of cloud-based databases
- Managed infrastructure (less ops).
- Automated scaling, backups, and patching.
- High availability and global replication options.
- Cost model: pay-as-you-go.

#### Disadvantages
- Vendor lock-in; proprietary features may be hard to migrate.
- Potential data residency concerns & compliance.
- Network latency for on-prem apps; costs for egress & storage.
- Less control over low-level tuning in fully managed services.

(Examples: Azure SQL, Amazon RDS/Aurora, Google Cloud Spanne

-------------------------------------------------------------------------
### Database Engines and Languages

#### What is a Database Engine?
- The software component that stores, retrieves, and manages access to data on disk and handles query processing, transactions, and storage management.

#### Examples
- SQL Server (Microsoft), MySQL, Oracle Database, PostgreSQL, MariaDB.

#### Languages used
- **ANSI SQL (standard SQL)** — core DDL/DML common to many engines.
- **T-SQL** — Transact-SQL (Microsoft SQL Server) — procedural extensions.
- **PL/SQL** — Procedural Language/SQL (Oracle) — Oracle’s procedural extensions.
- **PL/pgSQL** — PostgreSQL procedural language.
- Many engines provide their own procedural extensions, built-in functions, and administration tools.

#### Relationship between engine and language
- Core SQL is portable, but procedural extensions and some SQL dialects are engine-specific (e.g., T-SQL vs PL/SQL).
- Portability is possible with standard SQL for basic queries, but advanced functionality (stored procedures, specific datatypes) often needs conversion.

#### Can one language work across different engines?
- **Basic ANSI SQL** works across engines with minor syntax differences.
- **Procedural languages** and vendor-specific features do not transfer directly and need rewriting.

---------------------------------------------------------

### Can We Transfer a Database Between Engines?

#### Is migration possible?
- Yes, migrating between SQL Server ↔ MySQL ↔ PostgreSQL ↔ Oracle is possible and common.

#### Challenges
- **Data types differences** (e.g., `DATETIME2` vs `TIMESTAMP` precision).
- **Stored procedures and triggers** — different languages (T-SQL vs PL/pgSQL vs PL/SQL).
- **SQL dialect differences** — functions, query hints, proprietary features.
- **Constraints and defaults** — syntax & behavior differences.
- **Index types and optimizer hints**.
- **Permissions and security model**.
- **Large data transfer** — downtime considerations, replication or ETL needed.
- **Character sets/collations**.

#### What to consider before migrating
- Map data types and precision.
- Inventory stored procedures, triggers, views, UDFs — plan for rewrite.
- Plan data export/import (bulk copy, dump files, replication).
- Consider character set, collation, indices, partitioning.
- Plan for testing: functional, performance and integration tests.
- Security & user permissions migration.
- Choose migration approach: dump/load, replication, ETL, or use migration tools.

--------------------------------------------------------------------------------
## 5. Logical vs. Physical Schema

### What is the Logical Schema?
- Schema describing the data model from a business perspective: entities, relationships, attributes, and constraints — independent of storage details.
- Represented as ER diagrams, classes, or abstract table structures.

### What is the Physical Schema?
- Concrete implementation details: tables, columns with data types, indexes, partitions, filegroups, storage paths and engine-specific configuration.

### Difference & Importance
- **Logical** focuses on correctness and business rules.
- **Physical** focuses on performance, storage, and implementation.
- Designers must understand both: logical for correctness and normalization; physical for performance optimization and real-world constraints (disk, memory).

### Example: Student entity

**Logical schema (conceptual / logical):**
- Entity: Student
  - Attributes: StudentID (PK), FirstName, LastName, DateOfBirth, Email, Major, EnrollmentDate
  - Relationships: EnrolledIn -> Course (many-to-many via Enrollment)

**Physical schema (example SQL DDL for a relational engine):**
```sql
-- file: student_physical_schema.sql
CREATE TABLE Student (
  StudentID INT PRIMARY KEY,
  FirstName VARCHAR(100) NOT NULL,
  LastName VARCHAR(100) NOT NULL,
  DateOfBirth DATE,
  Email VARCHAR(255) UNIQUE,
  Major VARCHAR(100),
  EnrollmentDate DATE,
  -- indexes
  INDEX idx_lastname (LastName)
);

